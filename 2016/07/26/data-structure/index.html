<!doctype html>
<html class="theme-next use-motion theme-next-mala">
<head><meta name="generator" content="Hexo 3.9.0">
  

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5">



  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1">


    <meta name="description" content="half of iOSer, half of tester">



  <meta name="keywords" content="数据结构,">



  <link rel="alternate" href="/atom.xml" title="Sherlock" type="application/atom+xml">



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1">


<meta name="description" content="栈栈是只能在一端进行插入和删除的线性表。（别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。) 栈的特征：后进先出，先进后出。 插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作）另一端称为栈底。插入元素和删除元素的操作称为入栈和出栈。">
<meta name="keywords" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构简单要点总结（转）">
<meta property="og:url" content="http://sherlockz.github.io/2016/07/26/data-structure/index.html">
<meta property="og:site_name" content="Sherlock">
<meta property="og:description" content="栈栈是只能在一端进行插入和删除的线性表。（别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。) 栈的特征：后进先出，先进后出。 插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作）另一端称为栈底。插入元素和删除元素的操作称为入栈和出栈。">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://sherlockz.github.io/2016/07/26/data-structure/BTree.JPG">
<meta property="og:image" content="http://sherlockz.github.io/2016/07/26/data-structure/BTree2.JPG">
<meta property="og:image" content="http://sherlockz.github.io/2016/07/26/data-structure/BTree3.JPG">
<meta property="og:image" content="http://sherlockz.github.io/2016/07/26/data-structure/B-Tree.JPG">
<meta property="og:image" content="http://sherlockz.github.io/2016/07/26/data-structure/B-Tree2.JPG">
<meta property="og:image" content="http://sherlockz.github.io/2016/07/26/data-structure/B+Tree.JPG">
<meta property="og:image" content="http://sherlockz.github.io/2016/07/26/data-structure/B*Tree.JPG">
<meta property="og:updated_time" content="2016-07-28T03:04:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构简单要点总结（转）">
<meta name="twitter:description" content="栈栈是只能在一端进行插入和删除的线性表。（别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。) 栈的特征：后进先出，先进后出。 插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作）另一端称为栈底。插入元素和删除元素的操作称为入栈和出栈。">
<meta name="twitter:image" content="http://sherlockz.github.io/2016/07/26/data-structure/BTree.JPG">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mala',
    sidebar: 'post'
  };
</script>

  <title> 数据结构简单要点总结（转） | Sherlock </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">trace your love</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br>
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br>
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br>
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br>
            About
          </a>
        </li>
      

      
      
    </ul>
  

  
    <div class="site-search">
      
  
  <form class="site-search-form">
    <input type="text" id="st-search-input" class="st-search-input st-default-search-input">
  </form>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'Ls6_vyuHEGACo3ng2hvy','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              数据结构简单要点总结（转）
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2016-07-26T20:07:43+08:00" content="2016-07-26">
            2016-07-26
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2016/07/26/data-structure/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/26/data-structure/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是只能在一端进行插入和删除的线性表。<br>（别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。)</p>
<p>栈的特征：后进先出，先进后出。</p>
<p>插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作）<br>另一端称为栈底。<br>插入元素和删除元素的操作称为入栈和出栈。</p>
 <a id="more"></a>
<h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><p>结构：(top总是指向数组最后的元素，比如data[n]，而不是前面)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elementtype data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; seqstack;</span><br></pre></td></tr></table></figure>
<p>初始化栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_stack</span><span class="params">(seqstack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;    <span class="comment">//一个元素也没有，注意因为TOP是下标而不是元素个数，用-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断栈是否为空：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_empty</span><span class="params">(seqstack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取栈顶元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">elementtype <span class="title">stack_top</span><span class="params">(seqstack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stack_empty(S))</span><br><span class="line">        error(<span class="string">"栈为空！"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> S-&gt;data[S-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_stack</span><span class="params">(seqstack *S, elementtype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == MAXSIZE <span class="number">-1</span>)</span><br><span class="line">        error(<span class="string">"溢出！"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        S-&gt;data[++S-&gt;top] = x;    <span class="comment">//注意-&gt;运算符的优先级是最高的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">elementtype <span class="title">pop_stack</span><span class="params">(seqstack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stack_empty(S))</span><br><span class="line">        error(<span class="string">"栈为空！"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> S-&gt;data[S-&gt;top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断栈是否为满：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stack_full</span><span class="params">(seqstack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == MAXSIZE <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体来说，顺序栈很简单，出的时候取最后的元素，进的时候一样进在尾部。</p>
<h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><p>栈的链式存储结构称为链栈。<br>其插入和删除操作仅限制在表头位置上进行。<br>由于只能在链表头部进行操作，故链栈没有必要象单链表那样添加头结点。栈顶指针就是链表的头指针。<br>结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>    //和一般链表的结构一样。</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elementtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; linkstack; </span><br><span class="line">linkstack *top;</span><br></pre></td></tr></table></figure>
<p>当top=NULL时，链栈为空栈。</p>
<p>入栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_stack</span><span class="params">(linkstack *top, elementtype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    linkstack *P = (linkstack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linkstack));</span><br><span class="line">    P-&gt;data = x;</span><br><span class="line">    P-&gt;next = top-&gt;next;</span><br><span class="line">    top = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">elementype <span class="title">pop_stack</span><span class="params">(linkstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    elementtype x;</span><br><span class="line">    linkstack *P;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="literal">NULL</span>)</span><br><span class="line">        error(<span class="string">"栈为空！"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = top-&gt;data;</span><br><span class="line">        P = top;</span><br><span class="line">        top = top-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(P);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是只能在一端插入，另一端删除的线性表。<br>特征是：先进先出，后进后出。</p>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>注意顺序队列多是循环队列，这里要注意几点：<br>(1)front是队头的前一个位置。<br>(2)尾部入队，头部出队。<br>(3)由于循环，任何的位置移动计算之后要取余：$P = (P + 1) % MAXSIZE $。<br>结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elementtype data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> front;    <span class="comment">//头序号（注意是队头的前一个位置）</span></span><br><span class="line">    <span class="keyword">int</span> rear;    <span class="comment">//尾序号（直接指向尾元素）</span></span><br><span class="line">&#125; seqqueue;</span><br></pre></td></tr></table></figure>
<p>初始化队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_queue</span><span class="params">(seqqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_queue</span><span class="params">(seqqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;front = MAXSIZE - <span class="number">1</span>;</span><br><span class="line">    Q-&gt;rear = MAXSIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种方法的区别是第一种插入第一个元素是data[1]，而第二种是data[0]。<br>判断队列是否为空：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_empty</span><span class="params">(seqqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断队列是否为满：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_full</span><span class="params">(seqqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取队头元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">elementtype <span class="title">queue_front</span><span class="params">(seqqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue_empty(Q))</span><br><span class="line">        error(<span class="string">"队列为空！"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Q-&gt;data[(Q-&gt;front + <span class="number">1</span>) % MAXSIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(seqqueue *Q, elementtype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue_full(Q))</span><br><span class="line">        error(<span class="string">"队列满！"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;    <span class="comment">//千万不能直接用Q-&gt;rear++，在循环队列要特别注意</span></span><br><span class="line">        Q-&gt;data[Q-&gt;rear] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">elementtype <span class="title">Outqueue</span><span class="params">(seqqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue_empty(Q))</span><br><span class="line">        error(<span class="string">"队列为空！"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> Q-&gt;data[Q-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><p>出队时，删除表头操作，入队时，在表尾添加结点。（也就是头部出，尾部进）<br>使用带头结点的单链表形式。（注意链栈是不带头结点的）<br>结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mynode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elementtype data;</span><br><span class="line">    mynode *next;</span><br><span class="line">&#125; node;    <span class="comment">//就是单链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    node *front;</span><br><span class="line">    node *rear;</span><br><span class="line">&#125; linkqueue;</span><br></pre></td></tr></table></figure>
<p>初始化队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_queue</span><span class="params">(linkqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;front = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));    <span class="comment">//生成头结点（注意是NODE类型，Q结构是已有的一个结构，这里有点特殊，仔细体会）</span></span><br><span class="line">    Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    Q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断队列是否为空：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_empty</span><span class="params">(linkqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取队头元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">elementtype <span class="title">queue_front</span><span class="params">(linkqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queue_empty(Q))</span><br><span class="line">        error(<span class="string">"队列为空！"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Q-&gt;front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(linkqueue *Q, elementtype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *P = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">    P-&gt;data = x;</span><br><span class="line">    P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = P;</span><br><span class="line">    Q-&gt;rear = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">elementtype <span class="title">Outqueue</span><span class="params">(linkqueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *P;</span><br><span class="line">    elmenttype x;</span><br><span class="line">    <span class="keyword">if</span> (queue_empty(Q))</span><br><span class="line">        error(<span class="string">"队列为空！"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        P = Q-&gt;front-&gt;next;</span><br><span class="line">        Q-&gt;front-&gt;next = P-&gt;next;</span><br><span class="line">        x = P-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//只剩一个结点删除后队列为空时的特殊情况，一定要注意处理</span></span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>主要是稀疏矩阵的压缩存储：<br>当数组中非零元素非常少时，称之为稀疏矩阵。<br>存储特别如下：<br>(1)对稀疏矩阵压缩存储时，除了存储非零元素的值v以外，还要存储其行列号i和j，故每个元素对应一个三元组(i, j, v)。将这些元素的三元组组织起来构成三元组表。<br>(2)需要在三元组表中增设元素个数、行列数，以唯一确定一个稀疏矩阵。</p>
<p>结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>    //三元组结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    elementtype v;</span><br><span class="line">&#125; tuple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;    <span class="comment">//行数、列数、非0元素个数</span></span><br><span class="line">    tuple data[MAXSIZE];</span><br><span class="line">&#125; spmatrix;</span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h4><p>树中的每个结点最多只有一个前驱（父辈），但可能有多个后继（后代）。<br>一个结点的度是指该结点的孩子数目。<br>若一个结点的度为0，称为叶子结点或终结点，否则称为分支结点或非终结点。<br>一棵树的度是树中最大的结点的度。<br>某个结点的子树的根称为其孩子结点，而该结点为其孩子结点的双亲结点或父结点。<br>同一个结点的孩子互相称为兄弟结点。<br>根的层次为1，其余结点的层次为父结点的层次数加1，而最大的层次数称为树的高度或深度。<br>如果树中各兄弟结点之间的排列次序是无关的，则称之为有序树，否则称为无序树。<br>称多棵树为森林。</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树和树一样，都可以为空树。<br>注意二叉树每个结点的孩子都有左右之分，每个结点都有左右两个子树，这与树结构明显不同。<br>二叉树和树本质上是完全不同的两种结构。<br> 定义：满二叉树是指每层都有最大数目结点的二叉树，即高度为k的满二叉树中有2k-1个结点。而完全二叉树则是指在满二叉树的最下层从右到左连续地删除若干个结点所得到的二叉树。 </p>
<p>二叉树的性质：</p>
<p> 在二叉树的第i层上的结点个数$&lt;=2^{i-1}$(i&gt;0)<br> 深度（高度）为k的二叉树的结点个数$&lt;=2^k-1$<br>3.对任一棵非空的二叉树，如果其叶子数为$n_0$, 度为2的结点数为$n_2$, 则有下面的关系式成立：$n_0=n_2+1$<br>(这个性质很重要。主要是有个概念：除去根结点，每个结点都与一个它上面的分支一一对应，也就是说，结点数＝分支数＋1，所以有：$n-1=n_1+2*n_2$)<br>4.有n个结点的完全二叉树(n&gt;0)的深度为[log2n]+1([]为取整)<br>5.在编号的完全二叉树中，各结点的编号之间的关系为：<br>编号为i的结点如果存在左孩子，则其编号为2i，如果存在右孩子，则其编号为2i+1，如果存在父结点，则其编号为[i/2]。</p>
<p>二叉树的存储结构：<br> 顺序存储结构：<br>按完全二叉树的编号次序进行，即编号为i的结点存储在数组中下标为i的元素中。<br>缺点：若二叉树不是完全二叉树，则为了保持结点之间的关系，不得不空出许多元素来，这就造成了空间的浪费。</p>
<p> 二叉链表存储结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; bitree;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h4><p>所谓遍历二叉树是指按某种次序访问二叉树中每个结点一次且仅一次。<br>根据访问根结点的次序，可以分为先序遍历，中序遍历，后序遍历。<br>先序遍历可描述为：<br>若二叉树T不为空：<br>(1)访问T的根结点；<br>(2)先序遍历T的左子树；<br>(3)先序遍历T的右子树。<br>遍历的算法非常简单，只写出先序遍历算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(bitree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(T);    <span class="comment">//一般用的最多的就是输出</span></span><br><span class="line">        preorder(T-&gt;lchild);</span><br><span class="line">        preorder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>线索二叉树主要是为了求解在某种次序下的前驱或后继结点。<br>将二叉树各结点中的空的左孩子指针域改为指向其前驱，空的右孩子指针域改为指向其后继。称这种新的指针（前驱或后继）为线索，所得到的二叉树被称为线索二叉树，将二叉树转变成线索二叉树的过程称为线索化。<br>同时，为了区分到底指针是指向前驱（后继）还是孩子，要加入两个标志来判断。<br>结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;    <span class="comment">//0为孩子，1为前驱或后继</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; ordertree;</span><br></pre></td></tr></table></figure>
<p>先序后继的求解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ordertree *<span class="title">presuc</span><span class="params">(ordertree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (P-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> P-&gt;lchild;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> P-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序后继：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ordertree *<span class="title">insuc</span><span class="params">(ordertree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ordertree *q = P-&gt;rchild;</span><br><span class="line">    <span class="keyword">if</span> (P-&gt;rtag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (q-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            q = q-&gt;lchild;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中序先驱：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ordertree *<span class="title">infore</span><span class="params">(ordertree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ordertree *q = P-&gt;lchild;</span><br><span class="line">    <span class="keyword">if</span> (P-&gt;ltag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (q-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">            q = q-&gt;rchild;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序先驱：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ordertree *<span class="title">postfore</span><span class="params">(ordertree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (P-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> P-&gt;rchild;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> P-&gt;lchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>即二叉搜索树或二叉排序树：</p>
<p>1.所有非叶子结点至多拥有两个儿子（Left和Right）；</p>
<p>2.所有结点存储一个关键字；</p>
<p>3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p>
<p>如：<br><img src="/2016/07/26/data-structure/BTree.JPG" alt="二叉查找树"><br>查找树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果查找树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么查找树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变查找树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p>
<p>如：<br><img src="/2016/07/26/data-structure/BTree2.JPG" alt="二叉查找树2"><br>但查找树在经过多次插入与删除后，有可能导致不同的结构：<br><img src="/2016/07/26/data-structure/BTree3.JPG" alt="二叉查找树3"><br>右边也是一个查找树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用查找树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；      </p>
<p>实际使用的B树都是在原查找树的基础上加上平衡算法，即“平衡二叉树”；如何保持查找树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的策略；</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>是一种多路搜索树（并不是二叉的）：</p>
<p>1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p>
<p>2.根结点的儿子数为[2, M]；</p>
<p>3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p>
<p>4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
<p>5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p>
<p>6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>
<p>7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>
<p>8.所有叶子结点位于同一层；</p>
<p>如：（M=3）<br><img src="/2016/07/26/data-structure/B-Tree.JPG" alt="B-树"><br>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<p>B-树的特性：</p>
<p>1.关键字集合分布在整颗树中；</p>
<p>2.任何一个关键字出现且只出现在一个结点中；</p>
<p>3.搜索有可能在非叶子结点结束；</p>
<p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>5.自动层次控制；</p>
<p>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：<br><img src="/2016/07/26/data-structure/B-Tree2.JPG" alt="B-树2"><br>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4><p>B+树是B-树的变体，也是一种多路搜索树：</p>
<p>1.其定义基本与B-树同，除了：</p>
<p>2.非叶子结点的子树指针与关键字个数相同；</p>
<p>3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树</p>
<p>（B-树是开区间）；</p>
<p>5.为所有叶子结点增加一个链指针；</p>
<p>6.所有关键字都在叶子结点出现；</p>
<p>如：（M=3）<br><img src="/2016/07/26/data-structure/B+Tree.JPG" alt="B+树"><br>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p>B+的特性：</p>
<p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>
<p>2.不可能在非叶子结点命中；</p>
<p>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p>
<p>4.更适合文件索引系统；</p>
<h4 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h4><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br><img src="/2016/07/26/data-structure/B*Tree.JPG" alt="B*树"><br>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3（代替B+树的1/2）；</p>
<p>B+树的分裂：<br>当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：</p>
<p>当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<p>小结</p>
<p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p>
<p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
<p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>
<h4 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h4><p> 树的存储结构：<br>(1)双亲表示法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> <span class="title">treelist</span>[<span class="title">MAXSIZE</span>];</span>    <span class="comment">//整个树的存储数组说明</span></span><br></pre></td></tr></table></figure>
<p>其中parent指示该结点父结点的下标，data存放结点的值。<br>优点：便于搜索相应结点的父结点和祖先结点。<br>缺点：若要搜索孩子结点或后代结点需要搜索整个表，浪费时间。</p>
<p>(2)孩子链表表示法<br>分别将每个结点的孩子结点连成一个链表，然后将各表头指针放在一个表中构成一个整体结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>    //链表中每个孩子结点的定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; listnode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>    //数组元素的定义，每个数组元素都是一个单链表，单头元素不同</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    datatype info;</span><br><span class="line">    listnode *firstchild;</span><br><span class="line">&#125; arrnode;</span><br><span class="line">arrnode tree[MAXSIZE];    <span class="comment">//MAXSIZE为所有结点的个数</span></span><br></pre></td></tr></table></figure>
<p>优缺点：与双亲表示法恰好相反。</p>
<p>(3)孩子－兄弟链表表示法（二叉链表表示法，二叉树表示法）<br>树中每个结点用一个链表结点来存储，每个链表结点中除了存放结点的值外，还有两个指针，一个用来指示该结点的第一个孩子，另一个用于指示该结点的下一个兄弟结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    datatype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">firstchild</span>, *<span class="title">nextbrother</span>;</span></span><br><span class="line">&#125; tnode;</span><br></pre></td></tr></table></figure>
<p> 树（森林）与二叉树的转换<br>树或森林的子树转换为二叉树的左子树，兄弟转化为右子树。</p>
<p>3.树（森林）的遍历<br>树的遍历可分为先序遍历和后序遍历。（注意没有中序，因为树有不只两个孩子）即结点是在其子树之前还是之后访问。<br>遍历树（森林）要转换为遍历其对应的二叉树：<br>先序遍历：（同二叉树的先序遍历）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(tnode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        preorder(T-&gt;firstchild);</span><br><span class="line">        preorder(T-&gt;nextbrother);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历：（同二叉树的中序遍历）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(tnode *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder(T-&gt;firstchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        postorder(T-&gt;nextbrother);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树主要用来处理压缩算法。<br>一般的判断问题的流程就象是一棵二叉树，其中分支（判断）结点对应于二叉树的分支结点；而最后得出的结论对应于叶子结点；一个结论所需要的判断次数是从根结点到该叶子结点的分支线数（层次数-1）；每个结论成立的次数作为叶子结点的权值。<br>(这个权值可能比较少接触,但是其实它非常重要,因为我们平时设计的系统,判断的结果常常都是通过长年的实践会有一个出现机率分配,而不可能是平分的,比如考试,如果常常80-90分的比较多,也许就要换一种算法,当然这是后话,和考试无关了.)</p>
<p>哈夫曼算法步骤如下:<br>(1)根据给定的n个权值,构成一排结点T,每个的值都是相应的权值.<br>(2)从T中选两棵权值最小的二叉树,作为左右子树构成一棵新的二叉树T’,并且新二叉树的权值为左右子树权值之和.<br>(3)将新二叉树T’并入到T中,删除原来的两棵二叉树.<br>(4)重复2,3直到只剩一棵二叉树.这棵树就是哈夫曼树.</p>
<p>哈夫曼树的带权路径长度$WPL=\sum wL$<br>即所有叶子结点的 权值*比较次数(层次数-1) 之和.<br>而WPL也正好等于所有分支结点(不包括叶子结点)的值之和.</p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图中将每个对象用一个顶点表示，并常用一个序号来标识一个顶点。<br>其中弧表示单向关系，边表示双向关系，用离散数学中的术语来说，则分别表示为非对称关系和对称关系。<br>弧用&lt;A, B&gt;表示（A为尾，B为头），边用(A, B)表示。<br>一个图G由两部分内容构成，即顶点(vertex)集合(V)和边(或弧edge)的集合(E)，并用二元组(V, E)来表示，记做G = (V, E)<br>根据顶点间的关系是否有向而引入有向图和无向图。<br>给每条边或弧加上权值，这样的带权图称为网络。</p>
<p>若无向图中任意两点间都有一条边，则称此图G为无向完全图。(共有边数 $n*(n-1)/2$)</p>
<p>若有向图中任意一个顶点到其余各点间均有一条弧，则称为有向完全图。(共有弧数 $n*(n-1)$)</p>
<p>若一个图G1是从G中选取部分顶点和部分边（或弧）组成，则称G1是G的子图。（注意，顶点和边必须都为子关系）</p>
<p>若无向图中两个顶点i, j之间存在一条边，则称i, j相邻接，并互为邻接点。<br>在有向图中，若存在弧&lt;Vi, Vj&gt;，也做Vi, Vj相邻接，但为区别弧的头、尾顶点，可进一步称做Vi邻接到Vj，Vj邻接于Vi。</p>
<p>与一个顶点相邻接的顶点数称为该顶点的度。<br>在有向图中，进入一个顶点的弧数称为该顶点的入度，从一个顶点发出的弧数为该顶点的出度，并将入度和出度之和作为该顶点的度。</p>
<p>一个顶点经过一定的可经路程到达另一个顶点，就为顶点之间的路径。<br>若某路径所经过的顶点不重复，则称此路径为简单路径。<br>若某路径的首尾相同，则称此路径为回路（或称为环）。<br>若某回路的中间不重复，则称之为简单回路。</p>
<p>若无向图中任意两点之间均存在路径，则称G为连通图，否则不连通，就存在若干个连通分量。<br>若有向图中任意两点间可以互相到达，则称为强连通图。</p>
<p>一个无向图，连通并且无回路，称这样的图为树。<br>若有向图中仅有一个顶点的入度为0，其余顶点的入度都为1，称此图为有向树，入度为0的顶点为根。</p>
<p>图的存储结构：<br>1。邻接矩阵表示<br>对n个顶点的图来说，其邻接矩阵为n*n阶的。<br>邻接矩阵的元素存放边（弧）的权值，对不存在的边（弧），则用0或∞表示。<br>定义格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 6    <span class="comment">/* 图顶点数 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> e 8    <span class="comment">/* 图的边（弧）数 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    vextype vexs[n];    <span class="comment">/* 顶点类型 */</span></span><br><span class="line">    datatype arcs[n][n];    <span class="comment">/* 权值类型 */</span></span><br><span class="line">&#125; graph; </span><br><span class="line">建立一个无向网络的算法： </span><br><span class="line">CreateGraph(graph *G) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">int</span> i, j, k; </span><br><span class="line">    <span class="keyword">float</span> w; </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">        G-&gt;vexs[i] = getchar();    <span class="comment">/* 读入顶点信息，创建表，这里用字符型 */</span> </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) </span><br><span class="line">            G-&gt;arcs[i][j] = <span class="number">0</span>;    <span class="comment">/* 邻接矩阵初始化 */</span> </span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;e; k++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%f"</span>, &amp;i, &amp;j, &amp;w);    <span class="comment">/* 读入边(vi, vj)上的权w(暂用float类型) */</span> </span><br><span class="line">        G-&gt;arcs[i][j] = w; </span><br><span class="line">        G-&gt;arcs[j][i] = w; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 邻接表表示法<br>将每个顶点的邻接点连成链表，并将各链表的表头指针合在一起（用数组或链表表示均可），其中每个头指针与该结点的信息合为一个整体结点。<br>如果将邻接表中各顶点的邻接表变为其前驱顶点即可，从而得到逆邻接表。<br>用邻接表存储网络时，需要将各条边（弧）的权值作为相应邻接结点中的一个字段。<br>结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;    <span class="comment">/* 邻接点域 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span>    <span class="comment">/* 链域 */</span></span><br><span class="line">    datatype arc;    <span class="comment">/* 权值 */</span></span><br><span class="line">&#125; edgenode;    <span class="comment">/* 边表指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    vextype vertex;    <span class="comment">/* 顶点信息 */</span></span><br><span class="line">    edgenode *link;    <span class="comment">/* 边表头指针 */</span></span><br><span class="line">&#125; vexnode;    <span class="comment">/* 顶点表结点 */</span></span><br><span class="line">vexnode gnode[n];    <span class="comment">/* 整个图的构成 */</span></span><br></pre></td></tr></table></figure>
<p> 建立无向图的邻接表：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CreateAdjlist(gnode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    edgenode *s;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)    <span class="comment">/* 读入顶点信息 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        gnode[i].vertex = getchar();</span><br><span class="line">        gnode[i].link = <span class="literal">NULL</span>;    <span class="comment">/* 边表指针初始化 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;e; k++)    <span class="comment">/* 建立边表 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;i, &amp;j);    <span class="comment">/* 读入边(vi,vj)的顶点序号 */</span></span><br><span class="line">        s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(edgenode));    <span class="comment">/* 生成邻接点序号为j的表结点 */</span></span><br><span class="line">        s-&gt;adjvex = j;</span><br><span class="line">        s-&gt;next = gnode[i].link;</span><br><span class="line">        gnode[i].link = s;    <span class="comment">/* 将*s插入顶点vi的边表头部(插到头部比尾部简单) */</span></span><br><span class="line">        s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(edgenode));    <span class="comment">/* 生成邻接点序号为i的边表结点*s */</span></span><br><span class="line">        s-&gt;adjvex = i;</span><br><span class="line">        s-&gt;next = gnode[j].link;</span><br><span class="line">        gnode[j].link = s;    <span class="comment">/* 将*s插入顶点vj的边表头部(最后四行由于是无向图，所以相互，两次) */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图的遍历算法及其应用"><a href="#图的遍历算法及其应用" class="headerlink" title="图的遍历算法及其应用"></a>图的遍历算法及其应用</h4><p> 深度遍历<br>(1)访问V0<br>(2)依次从V0 的各个未被访问的邻接点出发深度遍历<br>（两句话说的非常清楚。是一种以深度为绝对优先的访问。）</p>
<p>2。深度优先搜索遍历算法<br>由于实际算法比较复杂，这里算法依赖两个函数来求解（对于不同的存储结构有不同的写法）<br>firstadj(G, v)：返回图G中顶点v的第一个邻接点。若不存在，返回0。<br>nextadj(G, v, w)：返回图G中顶点v的邻接点中处于w之后的那个邻接点。若不存在，返回0。<br>depth first search:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(graph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    w = firstadj(G, v)</span><br><span class="line">    <span class="keyword">while</span> (w != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[w] == <span class="number">0</span>)</span><br><span class="line">            dfs(w);</span><br><span class="line">        w = nextadj(G, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是连通图，或者是有向图，那么访问一个v不可能遍历所有顶点。所以，需要再选择未被访问的顶点作为起点再调用dfs.</p>
<p>所以，深度遍历图的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_travel</span><span class="params">(graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;        <span class="comment">//初始化各顶点的访问标志</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>)</span><br><span class="line">            dfs(G, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.广度优先搜索遍历算法<br>广度优先搜索遍历算法(bfs)是一种由近而远的层次遍历算法，从顶点V0出发的广度遍历bfs描述为：<br>(1)访问V0（可作为访问的第一层）；<br>(2)假设最近一层的访问顶点依次为V1, V2, …, Vk，则依次访问他们的未被访问的邻接点。<br>(3)重复2，直到找不到未被访问的邻接点为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(graph G, <span class="keyword">int</span> V0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="built_in">queue</span> Q;</span><br><span class="line">    init_queue(Q);</span><br><span class="line">    visit(V0);</span><br><span class="line">    visited[V0] = <span class="number">1</span>;</span><br><span class="line">    Enqueue(Q, V0);</span><br><span class="line">    <span class="keyword">while</span> (!empty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        v = Outqueue(Q);</span><br><span class="line">        w = firstadj(G, v);</span><br><span class="line">        <span class="keyword">while</span> (w != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[w] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                visit(w);</span><br><span class="line">                visited[w] = <span class="number">1</span>;</span><br><span class="line">                Enqueue(Q, w);</span><br><span class="line">            &#125;</span><br><span class="line">            w = nextadj(G, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广度遍历图的算法和深度一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs_travel</span><span class="params">(graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span> (visited[i] = <span class="number">0</span>)</span><br><span class="line">            bfs(G, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小生成树："><a href="#最小生成树：" class="headerlink" title="最小生成树："></a>最小生成树：</h4><p>从图中选取若干条边，将所有顶点连接起来，并且所选取的这些边的权值之和最小。<br>这样所选取的边构成了一棵树，称这样的树为生成树，由于权值最小，称为最小生成树。</p>
<p>构造最小生成树有两种方法：<br> Prim算法：<br>首先将所指定的起点作为已选顶点，然后反复在满足如下条件的边中选择一条最小边，直到所有顶点成为已选顶点为止（选择n-1条边）：一端已选，另一端未选。<br>(简单的说，就是先任选一点，然后每次选择一条最小权值的边，而且只连接到一个已选顶点)</p>
<p> Kruskal算法：<br>反复在满足如下条件的边中选出一条最小的，和已选边不够成回路。<br>(条件就是不够成回路就OK，反复选最小边，知道所有顶点都有连接）</p>
<p>最短路径：<br>一般即是要一个顶点到其余各个顶点的最短路径。（比如隔很远的顶点，要绕哪几条边走）<br>求解方法：<br>首先，我们要画一个表，每个顶点有path和dist两个值，分别用来存储到各点的最短路径（比如(1,5,6)，就是1-5-6这个路径）和相应的长度（到该点的权值之和）。<br>(1)对V以外的各顶点，若两点间的邻接路径存在，则将其作为最短路径和最短长度存到path[v]和dist[v]中。(实际上也就是最开始对顶点的直接后继进行处理）<br>(2)从未解顶点中选择一个dist值最小的顶点v，则当前的path[v]和dist[v]就是顶点v的最终解（从而使v成为已解顶点）。<br>(3)如果v的直接后继经过v会更近一些，则修改v的直接后继的path和dist值。</p>
<p>(上面的确是很难懂，只能通过例子自己慢慢熟悉。）<br> 查找</p>
<p>在软件设计中，通常是将待查找的数据元素集以某种表的形式给出，从而构成一种新的数据结构－－查找表。<br>表包括一些“元素”，“字段”等等概念。</p>
<p>在一个数据表中，若某字段的值可以标识一个数据元素，则称之为关键字（或键）。<br>若此关键字的每个值均可以唯一标识一个元素，则称之为主关键字，否则，若该关键字可以标识若干个元素，则称之为次关键字。</p>
<p>查找算法的时间性能一般以查找次数来衡量。所谓查找长度是指查找一个元素所进行的关键字的比较次数。常以平均查找次数、最大查找次数来衡量查找算法的性能。</p>
<h3 id="简单顺序查找"><a href="#简单顺序查找" class="headerlink" title="简单顺序查找"></a>简单顺序查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_seach</span><span class="params">(elementtype A[], <span class="keyword">int</span> n, keytype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    A[<span class="number">0</span>].key = x;        <span class="comment">//设定监视哨</span></span><br><span class="line">    <span class="keyword">for</span> (i=n; A[i].key!=x; i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监视哨是一个小技巧，查找失败时，这里设定的数据是A<a href="/data-structure/BTree.JPG">1</a>-A[n]，肯定可以在A[0]中找到该元素，并返回0表示查找失败。如果不设定监视哨，则在每次循环中要判断下标是否越界：for (i=1; i!=n&amp;&amp;A[i].key!=x;i–); 可以节省一半的时间。</p>
<h3 id="有序表的二分查找"><a href="#有序表的二分查找" class="headerlink" title="有序表的二分查找"></a>有序表的二分查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin_search</span><span class="params">(elementtype A[], <span class="keyword">int</span> n, keytype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid, low, high;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == A[mid].key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; A[mid].key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用递归算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin_search</span><span class="params">(elementtype A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, keytype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == A[mid].key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; A[mid],key)</span><br><span class="line">            <span class="keyword">return</span> bin_search(A, low, mid - <span class="number">1</span>, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> bin_search(A, mid - <span class="number">1</span>, high, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>增排序和减排序：如果排序的结果是按关键字从小到大的次序排列的，就是增排序，否则就是减排序。<br>内部排序和外部排序：如果在排序过程中，数据表中所有数据均在内存中进行，则这类排序为内部排序，否则就是外部排序。<br>稳定排序和不稳定排序：在排序过程中，如果关键字相同的两个元素的相对次序不变，则称为稳定排序，否则是不稳定排序。</p>
<p>在分析算法的时间性能时，主要以算法中用的最多的基本操作的执行次数（或者其数量级）来衡量，这些操作主要是比较、移动和交换元素。有时，可能要用这些次数的平均数来表示。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>基本思想：把整个待排序子表看作是左右两部分，其中左边为有序区，右边为无序区，整个排序过程就是把右边无序区中的元素逐个插入到左边的有序区中，以构成新的有序区。<br>实际中，开始排序时把第一个元素A[0]（或A[1]）看作左边的有序区，然后把剩下的2～N个元素依次插入到有序表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(elementtype A[n+<span class="number">1</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];        <span class="comment">//设置监视哨，这个数组同样是从1开始，A[0]就设为监视哨</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (A[j].key &gt; A[<span class="number">0</span>].key)</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明白这种方法的简单原理：<br>$a_1 a_2 a_3 … a_{i-1} a_i …$<br>先将ai临时保存起来，然后把$a_{i-1}$向前只要是比$a_i$大的向后移，再把$a_i$填进去即可。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>速度最快的办法！一定要掌握，考试重点。<br>基本思想：首先，选定一个元素作为中间元素，然后将表中所有元素与该中间元素相比较，将表中比中间元素小的元素调到表的前面，将比中间元素大的元素调到后面，再将中间数放在这两部分之间作为分界点，这样便得到一个划分；然后再对左右两部分分别进行快速排序，如此反复，直到每个子表仅有一个元素或空表为止。<br>中间数一般选择部分的第一个元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(elementtype A[n], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span>    <span class="comment">//s,t是要排序元素的起点和终点,并返回最后中间元素位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    elementtype x = A[s];    <span class="comment">//保存中间元素到临时变量x,以腾出空位</span></span><br><span class="line">    <span class="keyword">int</span> i = s;                        <span class="comment">//置两端搜索位置的初值</span></span><br><span class="line">    <span class="keyword">int</span> j = t;</span><br><span class="line">    <span class="keyword">while</span> (i != j)        <span class="comment">//两端位置重和再停止</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; A[j].key &gt; x.key) j--;    <span class="comment">//从后面搜索“小”的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)        <span class="comment">//如果找到，就调到前面的空位中</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = A[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; A[i].key &lt; x.key) i++;    <span class="comment">//从前面搜索“大”的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)        <span class="comment">//如果找到，调到后面的空位中</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j] = A[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[i] = x;        <span class="comment">//将中间数移到最终位置上</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(elementtype A[n], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span>    <span class="comment">//对数组中下标从s到t的部分进行快速排序，如果是整个表就是0, n-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; t)    <span class="comment">//表中至少有两个元素时</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = partition(A, s, t);    <span class="comment">//划分排序一次</span></span><br><span class="line">        quick_sort(A, i + <span class="number">1</span>, t);    <span class="comment">//对后面部分快速排序</span></span><br><span class="line">        quick_sort(A, s, i - <span class="number">1</span>);    <span class="comment">//对前面部分快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h4><p>在待排序子表中完整地比较一遍以确定最大（小）元素，并将该元素放在子表的最前（后）面。<br>【注：可能发觉和冒泡法比较类似，但注意选择法是全部比较一遍，找到最小元素的下标，再进行一次交换，而冒泡则是进行多次交换】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(elementtype A[n])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> min, i, j;</span><br><span class="line">   elementtype temp;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">for</span> (j=i+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">         <span class="keyword">if</span> (A[min].key &gt; A[j].key) min = j;</span><br><span class="line">      <span class="keyword">if</span> (min != i)</span><br><span class="line">      &#123;</span><br><span class="line">         temp = A[i];</span><br><span class="line">         A[i] = A[min];</span><br><span class="line">         A[min] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>所谓归并是指将两个或两个以上的有序表合并成一个新的有序表。<br>归并算法：<br>假设两个序列A[m]和B[n]为非降序列（即存在相同元素的升序列），现要把他们合并为一个非降序列C[m+n]。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(elementtype A[], elementtype B[], elementtype C[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia = <span class="number">0</span>, ib = <span class="number">0</span>, ic = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ia &lt; m &amp;&amp; ib &lt; n)</span><br><span class="line">        <span class="keyword">if</span> (A[ia] &lt;= B[ib])</span><br><span class="line">            C[ic++] = A[ia++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            C[ic++] = B[ib++];</span><br><span class="line">    <span class="keyword">while</span> (ia &lt; m)</span><br><span class="line">        C[ic++] = A[ia++];</span><br><span class="line">    <span class="keyword">while</span> (ib &lt; n)</span><br><span class="line">        C[ic++] = B[ib++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分转自：<a href="http://www.cnblogs.com/lebronjames/archive/2010/08/11/1797419.html" target="_blank" rel="noopener">天堂大鸟</a></p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag">#数据结构</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/15/HTTPCode/" rel="prev">Http状态码分析</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/23/sanya/" rel="next">这个暑假，这个三亚</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div>
      
        <style type="text/css">

    .donate_bar {
        text-align: center;
        margin-top : 5%;
    }

    .donate_bar.hidden {
        display:none;
    }
/*
    .donate_bar a.btn_donate {
        display: inline-block;
        width: 82px;
        height: 82px;
        margin-left:auto;
        margin-right:auto;

        background: url("http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif") no-repeat;
        _background: url("http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif") no-repeat; 

        -webkit-transition: background 0s;
        -moz-transition: background 0s;
        -o-transition: background 0s;
        -ms-transition: background 0s;
        transition: background 0s;
    }
*/
    .donate_bar a.btn_donate:hover { 
        // background-position: 0px -82px;
        color: #87daff;
    }

    .donate_bar .donate_txt {
        display: block;
        color: #9d9d9d;
        font: 14px/2 "Microsoft Yahei";
    }

    .bold { 
        font-weight: bold; 
    }

    .post-donate a {
        border-bottom: 0px;
    }

    #donate_guide table {
        border: none;
    }

    #donate_guide td {
        border-bottom: none;
        border-right: none;
        // background: #333333;
        valign: top;
    }

</style>



    

    <div class="post-donate">
        <div id="donate_board" class="donate_bar center">
              <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏">赏</a>
              <span id="donate_txt" class="donate_txt">
                   
                        仅仅是一个功能
                   
              </span>
            <br>
        </div>  
  
        <div id="donate_guide" class="donate_bar center hidden">
            <!--
            
                <a href="/img/aliPay.JPG" title="支付宝打赏" class="fancybox" rel="article0" 
                    style="float:left;margin-left:25%;margin-right:10px;">
                    <img src="/img/aliPay.JPG" title="" height="164px" width="164px">
                </a> 
              

            
                <a href="/img/wechatPay.JPG" title="微信打赏" class="fancybox" rel="article0"
                    style="margin-right:30%">
                    <img src="/img/wechatPay.JPG" title="" height="164px" width="164px">
                </a>
            
            -->
            <table>
                <tr>
                    <td>
                        
                            <a href="/img/aliPay.JPG" title="支付宝打赏" class="fancybox" rel="article0" style="float:left;margin-left:25%;margin-right:10px;">
                                <img src="/img/aliPay.JPG" title height="164px" width="164px">
                            </a> 
                         
                    </td>
                    <td>
                        
                            <a href="/img/wechatPay.JPG" title="微信打赏" class="fancybox" rel="article0" style="margin-right:30%">
                                <img src="/img/wechatPay.JPG" title height="164px" width="164px">
                            </a>
                        
                    </td>
                </tr>
            </table>

        </div>

        <script type="text/javascript">
            document.getElementById('btn_donate').onclick = function() {
                $('#donate_board').addClass('hidden');
                // $('#donate_guide').removeClass('hidden');
                $('#donate_guide').show(2000);
            }

        </script>
    </div>

    


      
    </div>

    <div class="post-spread">
      
        <div class="bdsharebuttonbox">
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
	<a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a>
	<a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              </div>
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table Of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/img/IMG_5048.jpg" alt="Locker" itemprop="image">
          <p class="site-author-name" itemprop="name">Locker</p>
        </div>
        <p class="site-description motion-element" itemprop="description">half of iOSer, half of tester</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">categories</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">20</span>
              <span class="site-state-item-name">tags</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://github.com/sherlockz" target="_blank">GitHub</a>
              </span>
            
          
        </div>

        <div class="links-of-friendly motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
              <a href="http://wayjam.me" target="_blank">WayJamSo</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="https://paulswith.github.io/" target="_blank">Dobby</a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
            </a>
          </div>
        

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#栈"><span class="nav-number">1.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序栈"><span class="nav-number">1.1.</span> <span class="nav-text">顺序栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链栈"><span class="nav-number">1.2.</span> <span class="nav-text">链栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列"><span class="nav-number">2.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序队列"><span class="nav-number">2.1.</span> <span class="nav-text">顺序队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链队列"><span class="nav-number">2.2.</span> <span class="nav-text">链队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">3.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树"><span class="nav-number">4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#树-1"><span class="nav-number">4.1.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树"><span class="nav-number">4.2.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的遍历："><span class="nav-number">4.3.</span> <span class="nav-text">二叉树的遍历：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线索二叉树"><span class="nav-number">4.4.</span> <span class="nav-text">线索二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉查找树"><span class="nav-number">4.5.</span> <span class="nav-text">二叉查找树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树"><span class="nav-number">4.6.</span> <span class="nav-text">B-树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树-1"><span class="nav-number">4.7.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树-2"><span class="nav-number">4.8.</span> <span class="nav-text">B*树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树和森林"><span class="nav-number">4.9.</span> <span class="nav-text">树和森林</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈夫曼树"><span class="nav-number">4.10.</span> <span class="nav-text">哈夫曼树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图"><span class="nav-number">5.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#图的遍历算法及其应用"><span class="nav-number">5.1.</span> <span class="nav-text">图的遍历算法及其应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最小生成树："><span class="nav-number">5.2.</span> <span class="nav-text">最小生成树：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单顺序查找"><span class="nav-number">6.</span> <span class="nav-text">简单顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序表的二分查找"><span class="nav-number">7.</span> <span class="nav-text">有序表的二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">8.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序"><span class="nav-number">8.1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">8.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序："><span class="nav-number">8.3.</span> <span class="nav-text">选择排序：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序"><span class="nav-number">8.4.</span> <span class="nav-text">归并排序</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright">
  
  &copy; &nbsp;  2016 - 
  <span itemprop="copyrightYear">2020
  </span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Locker
  </span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme by <a class="theme-link" href="http://blog.idhyt.com">idhyt</a>.<a class="theme-link" href="https://github.com/idhyt/hexo-theme-next/tree/magiclamp">Mala</a>
</div>

<!-- busuanzi -->



 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'sherlockz';
      var disqus_identifier = '2016/07/26/data-structure/';
      var disqus_title = '数据结构简单要点总结（转）';
      var disqus_url = 'http://sherlockz.github.io/2016/07/26/data-structure/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
